// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.1
// source: rpc/main.proto

package pb

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Langchain_Models_FullMethodName  = "/langchani.Langchain/Models"
	Langchain_Prompt_FullMethodName  = "/langchani.Langchain/Prompt"
	Langchain_Indexes_FullMethodName = "/langchani.Langchain/Indexes"
	Langchain_Chains_FullMethodName  = "/langchani.Langchain/Chains"
	Langchain_Agents_FullMethodName  = "/langchani.Langchain/Agents"
	Langchain_Memory_FullMethodName  = "/langchani.Langchain/Memory"
)

// LangchainClient is the client API for Langchain service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LangchainClient interface {
	Models(ctx context.Context, in *ModelsRequest, opts ...grpc.CallOption) (*ModelsResponse, error)
	Prompt(ctx context.Context, in *PromptRequest, opts ...grpc.CallOption) (*PromptResponse, error)
	Indexes(ctx context.Context, in *IndexesRequest, opts ...grpc.CallOption) (*IndexesResponse, error)
	Chains(ctx context.Context, in *ChainsRequest, opts ...grpc.CallOption) (*ChainsResponse, error)
	Agents(ctx context.Context, in *AgentsRequest, opts ...grpc.CallOption) (*AgentsResponse, error)
	Memory(ctx context.Context, in *MemoryRequest, opts ...grpc.CallOption) (*MemoryResponse, error)
}

type langchainClient struct {
	cc grpc.ClientConnInterface
}

func NewLangchainClient(cc grpc.ClientConnInterface) LangchainClient {
	return &langchainClient{cc}
}

func (c *langchainClient) Models(ctx context.Context, in *ModelsRequest, opts ...grpc.CallOption) (*ModelsResponse, error) {
	out := new(ModelsResponse)
	err := c.cc.Invoke(ctx, Langchain_Models_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *langchainClient) Prompt(ctx context.Context, in *PromptRequest, opts ...grpc.CallOption) (*PromptResponse, error) {
	out := new(PromptResponse)
	err := c.cc.Invoke(ctx, Langchain_Prompt_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *langchainClient) Indexes(ctx context.Context, in *IndexesRequest, opts ...grpc.CallOption) (*IndexesResponse, error) {
	out := new(IndexesResponse)
	err := c.cc.Invoke(ctx, Langchain_Indexes_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *langchainClient) Chains(ctx context.Context, in *ChainsRequest, opts ...grpc.CallOption) (*ChainsResponse, error) {
	out := new(ChainsResponse)
	err := c.cc.Invoke(ctx, Langchain_Chains_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *langchainClient) Agents(ctx context.Context, in *AgentsRequest, opts ...grpc.CallOption) (*AgentsResponse, error) {
	out := new(AgentsResponse)
	err := c.cc.Invoke(ctx, Langchain_Agents_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *langchainClient) Memory(ctx context.Context, in *MemoryRequest, opts ...grpc.CallOption) (*MemoryResponse, error) {
	out := new(MemoryResponse)
	err := c.cc.Invoke(ctx, Langchain_Memory_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LangchainServer is the server API for Langchain service.
// All implementations must embed UnimplementedLangchainServer
// for forward compatibility
type LangchainServer interface {
	Models(context.Context, *ModelsRequest) (*ModelsResponse, error)
	Prompt(context.Context, *PromptRequest) (*PromptResponse, error)
	Indexes(context.Context, *IndexesRequest) (*IndexesResponse, error)
	Chains(context.Context, *ChainsRequest) (*ChainsResponse, error)
	Agents(context.Context, *AgentsRequest) (*AgentsResponse, error)
	Memory(context.Context, *MemoryRequest) (*MemoryResponse, error)
	mustEmbedUnimplementedLangchainServer()
}

// UnimplementedLangchainServer must be embedded to have forward compatible implementations.
type UnimplementedLangchainServer struct {
}

func (UnimplementedLangchainServer) Models(context.Context, *ModelsRequest) (*ModelsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Models not implemented")
}
func (UnimplementedLangchainServer) Prompt(context.Context, *PromptRequest) (*PromptResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Prompt not implemented")
}
func (UnimplementedLangchainServer) Indexes(context.Context, *IndexesRequest) (*IndexesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Indexes not implemented")
}
func (UnimplementedLangchainServer) Chains(context.Context, *ChainsRequest) (*ChainsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Chains not implemented")
}
func (UnimplementedLangchainServer) Agents(context.Context, *AgentsRequest) (*AgentsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Agents not implemented")
}
func (UnimplementedLangchainServer) Memory(context.Context, *MemoryRequest) (*MemoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Memory not implemented")
}
func (UnimplementedLangchainServer) mustEmbedUnimplementedLangchainServer() {}

// UnsafeLangchainServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LangchainServer will
// result in compilation errors.
type UnsafeLangchainServer interface {
	mustEmbedUnimplementedLangchainServer()
}

func RegisterLangchainServer(s grpc.ServiceRegistrar, srv LangchainServer) {
	s.RegisterService(&Langchain_ServiceDesc, srv)
}

func _Langchain_Models_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LangchainServer).Models(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Langchain_Models_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LangchainServer).Models(ctx, req.(*ModelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Langchain_Prompt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PromptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LangchainServer).Prompt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Langchain_Prompt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LangchainServer).Prompt(ctx, req.(*PromptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Langchain_Indexes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IndexesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LangchainServer).Indexes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Langchain_Indexes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LangchainServer).Indexes(ctx, req.(*IndexesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Langchain_Chains_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChainsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LangchainServer).Chains(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Langchain_Chains_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LangchainServer).Chains(ctx, req.(*ChainsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Langchain_Agents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AgentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LangchainServer).Agents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Langchain_Agents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LangchainServer).Agents(ctx, req.(*AgentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Langchain_Memory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MemoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LangchainServer).Memory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Langchain_Memory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LangchainServer).Memory(ctx, req.(*MemoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Langchain_ServiceDesc is the grpc.ServiceDesc for Langchain service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Langchain_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "langchani.Langchain",
	HandlerType: (*LangchainServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Models",
			Handler:    _Langchain_Models_Handler,
		},
		{
			MethodName: "Prompt",
			Handler:    _Langchain_Prompt_Handler,
		},
		{
			MethodName: "Indexes",
			Handler:    _Langchain_Indexes_Handler,
		},
		{
			MethodName: "Chains",
			Handler:    _Langchain_Chains_Handler,
		},
		{
			MethodName: "Agents",
			Handler:    _Langchain_Agents_Handler,
		},
		{
			MethodName: "Memory",
			Handler:    _Langchain_Memory_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc/main.proto",
}
